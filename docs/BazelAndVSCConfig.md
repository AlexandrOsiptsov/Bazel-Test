# Конфигурация C++ проeкта на Bazel в VS Code (под ОС Linux)

## 1. Установка дополнительных пакетов

Сперва необходимо обновить пакетный менеджер `apt` и установить компиляторы `gcc`, `g++`, `clang`:

```sh
sudo apt update && sudo apt install gcc g++ clang -y
```

Также установим утилиты `apt-transport-https`, `curl`, `gnupg` для работы с сетью:

```sh
sudo apt apt-transport-https curl gnupg -y
```

## 2. Установка Bazel

Приступим к установке `bazel`.

Так как **Bazel** не включен в стандартные репозитории большинства дистрибутивов Linux, сразу при помощи пакетного менеджера его установить не получится, нужно добавить его вручную.

### Подготовка к установке

Добавьте **ключ GPG** (ключевое кольцо) официального репозитория **Bazel**:

```sh
curl -fsSL https://bazel.build/bazel-release.pub.gpg | gpg --dearmor >bazel-archive-keyring.gpg
```

Переместите **ключевое кольцо** в директорию системных ключевых колец, где `apt` хранит доверенные ключи для верификации пакетов и репозиториев:

```sh
sudo mv bazel-archive-keyring.gpg /usr/share/keyrings
```

Добавьте репозиторий **Bazel** в список источников `apt`:

```sh
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/bazel-archive-keyring.gpg] https://storage.googleapis.com/bazel-apt stable jdk1.8" | sudo tee /etc/apt/sources.list.d/bazel.list
```

### Установка и обновление

Наконец, можно приступить к непосредственной установке через `apt`

```sh
sudo apt update && sudo apt install bazel
```

Для надёжности можно обновить и остальные системные пакеты следующей командой

*(этот шаг можно пропустить)*

```sh
sudo apt update && sudo apt full-upgrade
```

**WARN:** Учтите, что может потребоваться немалое кол-во свободного места на диске. Перед тем, как ввести **'y'** вниммательно прочитайте какие пакеты будут обновлены и сколько свободного места займёт обновление

Для проверки успешности установки пропишите стандартную команду

```sh
bazel --version
```

## 3. Архитектура Bazel проекта

### WORKSPACE

В **Bazel** для определения корня проекта используется файл **WORKSPACE**, в котором раньше прописывались зависимости и некоторые настройки. На момент написания этого туториала Bazel всё ещё поддерживает подтягивание зависимостей через файл **WORKSPACE**, однако в Google документации по **Bazel** указано, что с новыми версиями эта поддержка пропадёт, она полностью мигрирует на `bzlmod` архитектуру, которую мы и будем использовать. А **WORKSPACE** принято оставлять пустым, можно разве что написать поясняющий комментаний:

```sh
## WORKSPACE


# This file marks the root of the Bazel workspace.
# See MODULE.bazel for external dependencies setup.
```

 Подробнее о миграции с **WORKSPACE** на **Bzlmod**: [Bzlmod Migration Guide](https://bazel.build/external/migration).

### .bazelrc

Ещё одним ключевым файлом в Bazel-проекте является **.bazelrc** (помещается в корневой директории), в котором записываются основные настройки сборки проекта. Там прописываются используемые при сборке компиляторы, стандарты языка, некоторые настройки обработчика ошибок, настройки разных пользовательских типов сборок (да, он и такое умеет). 

Так вот для перехода на ранее упомянутый **bzlmod** необходимо в **.bazelrc**  прописать:

```sh
## .bazelrc

common --enable_bzlmod
```

### MODULE.bazel

Теперь управление зависимостями происходит через файл **MODULE.bazel** (помещается в корневой директории), который инициализируется следующим:

```sh
## MODULE.bazel

module(
    name = "cpp_app",
    repo_name = "cpp_app",
    version = "1.0",
    compatibility_level = 1
)
```

Рассмотрим подключение внешних зависимостей на примере библиотеки тестирования `googletest`. В **bzlmod** есть одна интересная особенность: для него был написан **Bazel Central Registry** ([BCR](https://registry.bazel.build/)) - реестр, содержащий проверенные репозитории популярных библиотек, которые можно подтягивать в **MODULE.bazel** с указанием только названия и версии модуля:

```sh
## MODULE.bazel

bazel_dep(name = "googletest", version = "1.14.0")
```

Для того, чтобы подтянуть библиотеку, которой нет в **BCR** (какую-нибудь [`bee2`](https://github.com/agievich/bee2) *С.В. Агиевича*), можно воспользоваться синтаксисом, который использовался и в старых версиях в **WORKSPACE**:

```sh
## MODULE.bazel

load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
http_archive(
    name = "foo",
    urls = ["https://example.com/foo.zip"],
    sha256 = "c9526390a7cd420fdcec2988b4f3626fe9c5b51e2959f685e8f4d170d1a9bd96"
)
```

где поле `sha256` - это хэш скачиваемого архива (очевидно, хеш-функции **SHA256**), который нужно указать заранее.


Подробнее о **bzlmod**: [External dependencies overview](https://bazel.build/external/overview#bzlmod)

### MODULE.bazel.lock

После первого запуска сборки **Bazel** сгенерирует ещё один файл - **MODULE.bazel.lock**. Это системный файл, который хранит формальное описание подключенных модулей в **json** формате, модифицировать его вручную не понадобится. 

### BUILD

Под каждый отдельный модуль в **Bazel** создаётся новая директория, с файлом **BUILD** в ней. В этом файле описывается специфика модуля, все его зависимости, видимость для других модулей проекта.

---

### Модули

Перейдём к конфигурированию модулей самого кода. Предположим, нашей целью является написание класса для работы с дробями. Сперва нужно определиться, где именно будет лежать код. Для этого создадим директорию **src/**, в которой будем хранить весь код. Создадим также директорию первого модуля `main` - **src/main/**, в котором будет **main.cpp** и определяющий этот модуль **BUILD** файл, содержимое которого рассмотрим чуть позже. 

Нам понадобятся ещё 2 модуля: `fraction` (файлы класса `Fraction`) и `tests` (тесты проекта) в директориях **src/fraction/** и **src/tests/** соответственно. В **src/fraction/** поместим файл заголовка класса **Fraction.hpp** и файл реализации **Fraction.cpp**, а в **src/tests/** файл с тестами для этого класса **FractionTest.cpp**. Помимо файлов с кодом в каждой из директорий нужно создать **BUILD** файл.

### Описание модулей

В **BUILD** файле модуля `fraction` укажем, что это **библиотека**, **имя модуля**, какие именно **файлы в него входят** и **видимость** модуля:

```sh
## src/fraction/BUILD

cc_library(
    name = "fraction",
    srcs = ["Fraction.cpp"],
    hdrs = ["Fraction.hpp"],
    visibility = ["//visibility:public"],
)
```

Теперь опишем модуль `main`:

```sh
## src/main/BUILD

cc_binary(
    name = "cpp_app",
    srcs = ["main.cpp"],
    deps = [
        "//src/fraction:fraction",
    ],
)
```

Для модуля `tests` укажем в его **BUILD** файле, что это модуль с **тестами**, который использует внешнюю библиотеку `googletest` и внутренний модуль `fraction`:

```sh
## src/tests/BUILD

cc_test(
    name = "tests",
    srcs = ["FractionTest.cpp"],
    deps = [
        "@googletest//:gtest_main",
        "//src/fraction:fraction",
    ]
)
```

### Сборка проекта

После того, как весь код написан, можно пробовать запускать сборку проекта:

```sh
bazel build //src/main:cpp_app
```

При **первом запуске** начнётся загрузка внешних модулей, если такие прописаны в **MODULES.bazel** (в нашем случае это модуль `googletest`), поэтому убедитесь в стабильном подключении к сети.

Скомпилированный **исполняемый файл** программы будет лежать по пути **bazel-bin/src/main/cpp_app**. Запустить, находясь в **корне проекта**, можно следующим образом:

```sh
./bazel-bin/src/main/cpp_app
```

Также **Bazel** позволяет собрать и сразу запустить скомпилированную программу при помощи команды `run`:

```sh
bazel run //src/main:cpp_app
```



После первой сборки также появятся **символические ссылки** (sym links, soft links) на следующие директории:

### bazel-bin

Cодержит **бинарные файлы**, которые были скомпилированы во время сборки. Используется и для хранения всех **сгенерированных артефактов**, которые могут быть непосредственно использованы или запущены пользователем. В зависимости от конфигурации проекта, здесь могут находиться **собранные программы**, **динамические** и **статические библиотеки** После успешного выполнения сборки вы найдете **конечные исполняемые файлы** внутри этой директории 

### bazel-out

Cодержит все **промежуточные файлы**, сгенерированные во время процесса сборки. Это включает **объектные файлы**, **временные файлы компиляции**, а также различные **артефакты**, специфичные для разных целей сборки (например, для разных платформ или конфигураций)

### bazel-testlogs

Предназначена для хранения **логов тестирования**. В этой директории собираются файлы журналов и результаты тестов, выполненных с помощью **Bazel**. Это включает подробные отчёты о прохождении тестов, ошибки, предупреждения и другую информацию, полезную для анализа результатов тестирования

### bazel-projectname

Эта директория является **рабочим каталогом Bazel** для конкретного проекта. **projectname** будет заменено на имя вашего проекта. Bazel использует эту директорию для хранения всех своих внутренних рабочих файлов, включая **промежуточные артефакты**, **кэшированные данные** и **инструменты для сборки**. Это корневая директория, в которой находятся все остальные специфичные для Bazel директории, поэтому не стоит удивляться "дублированию" директорий проекта в этой директории. Это **не копии**, а **символические ссылки** на них

---

Чтобы запустить все тесты модуля `tests` нужно прописать:

```sh
bazel test //src/tests:all
```

Здесь разными параметрами можно указать вид вывода, кэширование результатов, вывод только успешных/провальных тестов и т.д. 

Подробнее о командах **Bazel** и их параметрах можно узнать здесь: [Command-Line Reference](https://bazel.build/reference/command-line-reference)

==== TODO ===

### Анализ покрытия кода тестами с `bazel coverage`



## 4. Настройка VS Code под Bazel проект


=========== TODO: Добавить инфу ===========